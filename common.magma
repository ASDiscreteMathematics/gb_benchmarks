
vec_pow := func< vec, pow | Vector([i^pow : i in ElementToSequence(vec)]) >;
mat_pow := func< mat, pow | Matrix(NumberOfRows(mat), NumberOfColumns(mat), [i^pow : i in ElementToSequence(mat)]) >;

function sum_all (seq)
    r := 0;
    for x in seq do
        r +:= x;
    end for;
    return r;
end function;

function random_non_subfield_value (prime_field)
    assert IsPrime(#prime_field);
    while true do
        rand := Random(prime_field);
        if IsPrimitive(rand) then
            return rand;
        end if;
    end while;
end function;

function generate_mds_matrix (field, size)
    p := PrimitiveElement(field);
    mds := Matrix([[p^(i*j) : i in [1..size*2]] : j in [1..size]]);
    mds := EchelonForm(mds);
    mds := ColumnSubmatrix(mds, size + 1, size);
    mds := Transpose(mds);
    return mds;
end function;

function is_regular_sequence (poly_system)
    if #poly_system le 0 then return true; end if;
    if IsUnit(poly_system[1]) and #poly_system gt 1 then return false; end if;
    R := Parent(poly_system[1]);
    for i in [2..#poly_system - 1] do
        I := Ideal([poly_system[j] : j in [1..i]]);
        f := (R / I) ! poly_system[i+1];
        if IsZero(f) or IsZeroDivisor(f) then
            return false;
        end if;
    end for;
    return true;
end function;

function test_is_regular_sequence ()
    P<x, y> := PolynomialRing(GF(5), 2, "grevlex");
    assert not is_regular_sequence([x^2 - x + y, x*y - y + 1, y^2 - x]);
    assert not is_regular_sequence([x^2 + y, x*y - x - y, y^2 + x]);
    assert is_regular_sequence([x + 1, y - 1]);
    assert is_regular_sequence([y^3 + y^2 + x - y + 1, x^2 + y^2 + y + 1, x*y - y - 1]);
    assert is_regular_sequence([x^2 - x*y + y^2 + y]);
    return true;
end function;

function macaulay_bound (poly_system)
    return 1 + sum_all( [Degree(poly) - 1 : poly in poly_system] );
end function;

function d_reg (poly_system)
    if IsGroebner(poly_system) then
        ret, _ := Max([Degree(poly) : poly in poly_system]);
        return ret;
    end if;
    if is_regular_sequence (poly_system) then
        return macaulay_bound (poly_system);
    end if;
    gb, degs := GroebnerBasis(Ideal(poly_system));
    d, pos := Max(degs);
    return d;
end function;
