security_level := 0;
field_size := 101;
s_box_power := 3;
state_size := 2;
num_lower_number_of_rounds := 2;

SetSeed(42);
SetNthreads(8);
lower_number_of_rounds := true; // artifitially decrease security level for analytic purposes
switch_s_boxes := true; // Rescue_prime if enabled, plain old Rescue otherwise.
order := "lex";

import "common.magma" : vec_pow, mat_pow, random_non_subfield_value, generate_mds_matrix;

function rescue_initialize (security_level, field_size, state_size, s_box_power)
    assert IsPrime(field_size);
    assert state_size ge 1;
    assert Log(2, field_size) * state_size ge security_level;
    assert Gcd(s_box_power, field_size - 1) eq 1;
    // field
    field := FiniteField(field_size);
    // power of the inverse S-Box
    _, inv_s_box_power, _ :=  Xgcd(s_box_power, field_size - 1);
    while inv_s_box_power lt 0 do
        inv_s_box_power := inv_s_box_power + field_size - 1;
    end while;
    // determine number of rounds
    num_rounds := Max([10, 2 * Ceiling( (security_level + 2) / (4 * state_size))]);
    if s_box_power gt 3 then
        num_rounds := Max([10, 2 * Ceiling( (security_level + 3) / (5.5 * state_size))]);
    end if;
    if lower_number_of_rounds and num_rounds gt num_lower_number_of_rounds then // artificially lower the number of rounds
        num_rounds := num_lower_number_of_rounds;
    end if;
    // generate mds matrix
    mds := generate_mds_matrix(field, state_size);
    // sample initial constant vector
    constant_initial := [field | ]; // declare universe of sequence
    repeat
        Append(~constant_initial, random_non_subfield_value(field));
    until #constant_initial eq state_size;
    constant_initial := Matrix(field, state_size, 1, constant_initial);
    // sample constant matrix
    repeat
        constant_matrix := [field | ];
        repeat
            Append(~constant_matrix, random_non_subfield_value(field));
        until #constant_matrix eq state_size^2;
        constant_matrix := Matrix(field, state_size, state_size, constant_matrix);
    until IsInvertible(constant_matrix);
    // sample affine transformation of subsequent round constants
    constant_constants := [field | ];
    repeat
        Append(~constant_constants, random_non_subfield_value(field));
    until #constant_constants eq state_size;
    constant_constants := Matrix(field, state_size, 1, constant_constants);
    return field, inv_s_box_power, mds, constant_initial, constant_matrix, constant_constants, num_rounds;
end function;

// initialize
field, inv_s_box_power, mds, constant_initial, constant_matrix, constant_constants, num_rounds := rescue_initialize(security_level, field_size, state_size, s_box_power);

function rescue_encrypt (key, plaintext : sub_steps := false, switch_s_boxes := false)
    assert Parent(key) eq Parent(plaintext);
    assert Parent(key) eq Parent(constant_initial);
    assert Type(key) eq Type(plaintext);
    assert Type(key) eq Type(constant_initial);
    assert #ElementToSequence(key) eq state_size;
    assert #ElementToSequence(plaintext) eq state_size;

    key_injection := constant_initial;
    key_state := key + key_injection;
    data_state := plaintext + key_state;
    all_constants := [key_injection];
    all_keys := [key_state];
    all_data := [data_state];
    all_variables := [key];

    index_of_inverse_s_box := 1;
    if switch_s_boxes then
        index_of_inverse_s_box := 0;
    end if;

    for r in [1..2*num_rounds] do
        step_power := s_box_power;
        if r mod 2 eq index_of_inverse_s_box then
            step_power := inv_s_box_power;
        end if;
        key_injection := constant_matrix * key_injection + constant_constants;
        key_state := mds * mat_pow(key_state, step_power) + key_injection;
        data_state := mds * mat_pow(data_state, step_power) + key_state;
        all_constants cat:= [key_injection];
        all_keys cat:= [key_state];
        all_data cat:= [data_state];
        if not switch_s_boxes then
            if sub_steps and r mod 2 eq 1 then
                all_variables cat:= [data_state, key_state];
            end if;
        else
            if sub_steps and r ge 1 and r mod 2 eq 0 then
                all_variables cat:= [key_state, data_state];
            end if;
        end if;
    end for;

    if sub_steps then
        all_variables := [all_variables[i,j,1] : j in [1..#ElementToSequence(all_variables[i])], i in [1..#all_variables]]; // flatten
        if switch_s_boxes then
            all_variables := all_variables[1..2*num_rounds*state_size]; // truncate ciphertext
        end if;
        return data_state, all_constants, all_keys, all_data, all_variables;
    end if;
    return data_state;
end function;

function rescue_decrypt (key, ciphertext)
    assert Parent(key) eq Parent(ciphertext);
    assert Parent(key) eq Parent(constant_initial);
    assert Type(key) eq Type(ciphertext);
    assert Type(key) eq Type(constant_initial);
    key_state := key;
    data_state := ciphertext;
    // TODO
    return data_state;
end function;

function rescue_sponge (inputs, rate)
    assert NumberOfColumns(inputs) eq 1;
    assert BaseField(Parent(inputs)) eq field;
    assert rate le state_size;
    key := ZeroMatrix(field, state_size, 1);
    state := ZeroMatrix(field, state_size, 1);
    for i in [1..NumberOfRows(inputs) by rate] do
        for j in [1..Min(rate, NumberOfRows(inputs) - i)] do
            state[j, 1] := state[j, 1] + inputs[i+j, 1];
        end for;
        state := rescue_encrypt(key, state);
    end for;
    return RowSubmatrix(state, rate);
end function;

// absolutely minimal testing
function test_rescue_encrypt ()
    key := Matrix(field, state_size, 1, [0..6]);
    pt := Matrix(field, state_size, 1, [40..46]);
    return rescue_encrypt(key, pt);
end function;

function test_rescue_sponge ()
    msg := Matrix(field, 31, 1, [0..30]);
    return rescue_sponge(msg, 4);
end function;

function polynomial_system (plaintext, ciphertext : sub_steps := false)
    assert num_rounds ge 1;
    assert Parent(constant_initial) eq Parent(plaintext);
    assert Parent(constant_initial) eq Parent(ciphertext);
    assert Type(constant_initial) eq Type(plaintext);
    assert Type(constant_initial) eq Type(ciphertext);
    assert #ElementToSequence(plaintext) eq state_size;
    assert #ElementToSequence(ciphertext) eq state_size;

    num_vars := (2*num_rounds + 1)*state_size;
    P<[x]> := PolynomialRing(field, num_vars, order); // k_0 = P.[1..m], s_i = P.[i*m+1..(i+1)*m], k_i = P.[(i+1)*m+1..(i+2)*m]
    mds_P := Matrix(P, NumberOfRows(mds), NumberOfColumns(mds), [P ! e : e in ElementToSequence(mds)]);
    inv_mds_P := mds_P^(-1);
    polynomial_equations := [];
    c_0 := constant_initial;
    c_1 := constant_matrix * c_0 + constant_constants;
    all_constants := [c_0, c_1];
    k := Matrix(P, state_size, 1, [P.i : i in [0*state_size+1..1*state_size]]); // master key
    s_r := Matrix(P, state_size, 1, [P.i : i in [1*state_size+1..2*state_size]]); // state "right" of current section
    k_r := Matrix(P, state_size, 1, [P.i : i in [2*state_size+1..3*state_size]]); // key "right" of current section
    k_m := mat_pow(inv_mds_P * (k_r - c_1), s_box_power); // technically k_0, which is never an explicit variable
    polynomial_equations cat:= ElementToSequence(k + c_0 - k_m); // master key
    polynomial_equations cat:= ElementToSequence(plaintext + k + c_0 - mat_pow(inv_mds_P * (s_r - k_r), s_box_power)); // first step in first round
    for rnd in [1..num_rounds-1] do // first step and last step are treated differently
        c_0 := constant_matrix * c_1 + constant_constants; // even numbered...
        c_1 := constant_matrix * c_0 + constant_constants; // ... and odd numbered round constant
        all_constants cat:= [c_0, c_1];
        s_l := s_r;
        s_r := Matrix(P, state_size, 1, [P.i : i in [(2*rnd+1)*state_size+1..(2*rnd+2)*state_size]]);
        k_l := k_r;
        k_r := Matrix(P, state_size, 1, [P.i : i in [(2*rnd+2)*state_size+1..(2*rnd+3)*state_size]]);
        k_m := mds_P * mat_pow(k_l, s_box_power) + c_0; // middle key, never an explicit variable
        polynomial_equations cat:= ElementToSequence(k_m - mat_pow(inv_mds_P*(k_r - c_1), s_box_power)); // key schedule
        polynomial_equations cat:= ElementToSequence(mds_P * mat_pow(s_l, s_box_power) + k_m - mat_pow(inv_mds_P * (s_r - k_r), s_box_power)); // second step of one round & first step of next round
    end for;
    c_0 := constant_matrix * c_1 + constant_constants;
    all_constants cat:= [c_0];
    polynomial_equations cat:= ElementToSequence(mds_P * mat_pow(s_r, s_box_power) + mds_P * mat_pow(k_r, s_box_power) + c_0 - ciphertext); // second step in last round
    if sub_steps then
        return polynomial_equations, all_constants;
    end if;
    return polynomial_equations;
end function;

function polynomial_system_switched_s_boxes (plaintext, ciphertext : sub_steps := false)
    assert num_rounds ge 1;
    assert Parent(constant_initial) eq Parent(plaintext);
    assert Parent(constant_initial) eq Parent(ciphertext);
    assert Type(constant_initial) eq Type(plaintext);
    assert Type(constant_initial) eq Type(ciphertext);
    assert #ElementToSequence(plaintext) eq state_size;
    assert #ElementToSequence(ciphertext) eq state_size;

    num_vars := 2*num_rounds*state_size;
    P<[y]> := PolynomialRing(field, num_vars, order); // k, k_2, s_2, k_4, s_4, ..., k_(r-2), s_(r-2), k_r.
    mds_P := Matrix(P, NumberOfRows(mds), NumberOfColumns(mds), [P ! e : e in ElementToSequence(mds)]);
    inv_mds_P := mds_P^(-1);
    polynomial_equations := [];
    c_0 := constant_initial;
    all_constants := [c_0];
    k_r := Matrix(P, state_size, 1, [P.i : i in [0*state_size+1..1*state_size]]) + c_0;
    s_r := plaintext + k_r;
    for rnd in [1..num_rounds] do
        c_1 := constant_matrix * c_0 + constant_constants;
        c_0 := constant_matrix * c_1 + constant_constants;
        all_constants cat:= [c_1, c_0];
        s_l := s_r;
        if rnd eq num_rounds then
            s_r := ciphertext;
        else
            s_r := Matrix(P, state_size, 1, [P.i : i in [2*rnd*state_size+1..(2*rnd+1)*state_size]]);
        end if;
        k_l := k_r;
        k_r := Matrix(P, state_size, 1, [P.i : i in [(2*rnd-1)*state_size+1..2*rnd*state_size]]);
        k_mid := mds_P*mat_pow(k_l, s_box_power) + c_1;
        polynomial_equations cat:= ElementToSequence(k_mid - mat_pow(inv_mds_P*(k_r - c_0), s_box_power));
        polynomial_equations cat:= ElementToSequence(mds_P*mat_pow(s_l, s_box_power) + k_mid - mat_pow(inv_mds_P*(s_r - k_r), s_box_power));
    end for;
    if sub_steps then
        return polynomial_equations, all_constants;
    end if;
    return polynomial_equations;
end function;

function test_polynomial_system (key, plaintext : switch_s_boxes := false)
    ciphertext, cs, ks, ds, vs := rescue_encrypt(key, plaintext : sub_steps := true, switch_s_boxes := switch_s_boxes);
    eqs, css := polynomial_system(plaintext, ciphertext : sub_steps := true);
    if switch_s_boxes then
        eqs, css := polynomial_system_switched_s_boxes(plaintext, ciphertext : sub_steps := true);
    end if;
    assert cs eq css;
    return [Evaluate(eqs[i], ElementToSequence(vs)) : i in [1..#eqs]];
end function;

SetNthreads(8);
key := Matrix(field, state_size, 1, [1..state_size]);
pt := Matrix(field, state_size, 1, [1..state_size]);
ct, cs, ks, ds, vs := rescue_encrypt(key, pt : sub_steps := true, switch_s_boxes:= switch_s_boxes);
eqs, css := polynomial_system(pt, ct : sub_steps := true);
if switch_s_boxes then
    eqs, css := polynomial_system_switched_s_boxes(pt, ct : sub_steps := true);
end if;
eqs_tested := test_polynomial_system(key, pt : switch_s_boxes := switch_s_boxes);
SetVerbose("Groebner", 3);
gb := GroebnerBasis(Ideal(eqs));
v := Variety(Ideal(gb));
dreg := Max([Degree(gb[i]) : i in [1..#gb]]);
