security_level := 0;
field_size := 101;
state_size := 2;
s_box_power := 3;

SetSeed(42);
lower_number_of_rounds := true;

vec_pow := func< vec, pow | Vector([i^pow : i in ElementToSequence(vec)])>;
mat_pow := func< mat, pow | Matrix(NumberOfRows(mat), NumberOfColumns(mat), [i^pow : i in ElementToSequence(mat)])>;

function random_non_subfield_value (prime_field)
    assert IsPrime(#prime_field);
    while true do
        rand := Random(prime_field);
        if IsPrimitive(rand) then
            return rand;
        end if;
    end while;
end function;

function rescue_initialize (security_level, field_size, state_size, s_box_power)
    assert IsPrime(field_size);
    assert state_size ge 1;
    assert Log(2, field_size) * state_size ge security_level;
    assert Gcd(s_box_power, field_size - 1) eq 1;
    field := FiniteField(field_size);
    _, inv_s_box_power, _ :=  Xgcd(s_box_power, field_size - 1);
    while inv_s_box_power lt 0 do
        inv_s_box_power := inv_s_box_power + field_size - 1;
    end while;
    // determine number of rounds
    num_rounds := Max([10, 2 * Ceiling( (security_level + 2) / (4 * state_size))]);
    if s_box_power gt 3 then
        num_rounds := Max([10, 2 * Ceiling( (security_level + 3) / (5.5 * state_size))]);
    end if;
    if lower_number_of_rounds then
        num_rounds := 2;
    end if;
    // Generate MDS matrix
    p := PrimitiveElement(field);
    mds := Matrix([[p^(i*j) : i in [1..state_size*2]] : j in [1..state_size]]);
    mds := ColumnSubmatrix(EchelonForm(mds), state_size + 1, state_size);
    // Sample initial constant vector
    constant_initial := [];
    repeat
        Append(~constant_initial, random_non_subfield_value(field));
    until #constant_initial eq state_size;
    constant_initial := Matrix(field, state_size, 1, constant_initial);
    // Sample constant matrix
    repeat
        constant_matrix := [];
        repeat
            Append(~constant_matrix, random_non_subfield_value(field));
        until #constant_matrix eq state_size^2;
        constant_matrix := Matrix(field, state_size, state_size, constant_matrix);
    until IsInvertible(constant_matrix);
    // Sample affine transformation of subsequent round constants
    constant_constants := [];
    repeat
        Append(~constant_constants, random_non_subfield_value(field));
    until #constant_constants eq state_size;
    constant_constants := Matrix(field, state_size, 1, constant_constants);
    return field, inv_s_box_power, mds, constant_initial, constant_matrix, constant_constants, num_rounds;
end function;

// initialize
field, inv_s_box_power, mds, constant_initial, constant_matrix, constant_constants, num_rounds := rescue_initialize(security_level, field_size, state_size, s_box_power);

function rescue_encrypt (key, plaintext : sub_steps := false)
    assert Parent(key) eq Parent(plaintext);
    assert Parent(key) eq Parent(constant_initial);
    assert Type(key) eq Type(plaintext);
    assert Type(key) eq Type(constant_initial);
    assert #ElementToSequence(key) eq state_size;
    assert #ElementToSequence(plaintext) eq state_size;

    key_injection := constant_initial;
    key_state := key + key_injection;
    data_state := plaintext + key_state;
    all_constants := [key_injection];
    all_keys := [key_state];
    all_data := [data_state];

    for r in [1..2*num_rounds] do
        step_power := s_box_power;
        if r mod 2 eq 1 then
            step_power := inv_s_box_power;
        end if;
        key_injection := constant_matrix * key_injection + constant_constants;
        key_state := mds * mat_pow(key_state, step_power) + key_injection;
        data_state := mds * mat_pow(data_state, step_power) + key_state;
        all_constants cat:= [key_injection];
        all_keys cat:= [key_state];
        all_data cat:= [data_state];
    end for;

    if sub_steps then
        return data_state, all_constants, all_keys, all_data;
    end if;
    return data_state;
end function;

function rescue_decrypt (key, ciphertext)
    assert Parent(key) eq Parent(ciphertext);
    assert Parent(key) eq Parent(constant_initial);
    assert Type(key) eq Type(ciphertext);
    assert Type(key) eq Type(constant_initial);
    key_state := key;
    data_state := ciphertext;
    // TODO
    return data_state;
end function;

function rescue_sponge (inputs, rate)
    assert NumberOfColumns(inputs) eq 1;
    assert BaseField(Parent(inputs)) eq field;
    assert rate le state_size;
    key := ZeroMatrix(field, state_size, 1);
    state := ZeroMatrix(field, state_size, 1);
    for i in [1..NumberOfRows(inputs) by rate] do
        for j in [1..Min(rate, NumberOfRows(inputs) - i)] do
            state[j, 1] := state[j, 1] + inputs[i+j, 1];
        end for;
        state := rescue_encrypt(key, state);
    end for;
    return RowSubmatrix(state, rate);
end function;

// absolutely minimal testing
function test_rescue_encrypt ()
    key := Matrix(field, state_size, 1, [0..6]);
    pt := Matrix(field, state_size, 1, [40..46]);
    return rescue_encrypt(key, pt);
end function;

function test_rescue_sponge ()
    msg := Matrix(field, 31, 1, [0..30]);
    return rescue_sponge(msg, 4);
end function;

function polynomial_system (plaintext, ciphertext : sub_steps := false)
    assert Parent(constant_initial) eq Parent(plaintext);
    assert Parent(constant_initial) eq Parent(ciphertext);
    assert Type(constant_initial) eq Type(plaintext);
    assert Type(constant_initial) eq Type(ciphertext);
    assert #ElementToSequence(plaintext) eq state_size;
    assert #ElementToSequence(ciphertext) eq state_size;

    num_vars := (2*num_rounds + 1)*state_size;
    P<[x]> := PolynomialRing(field, num_vars); // k_0 = P.[1..m], s_i = P.[i*m+1..(i+1)*m], k_i = P.[(i+1)*m+1..(i+2)*m]
    mds_P := Matrix(P, NumberOfRows(mds), NumberOfColumns(mds), [P ! e : e in ElementToSequence(mds)]);
    inv_mds_P := mds_P^(-1);
    polynomial_equations := [];
    c_0 := constant_initial;
    c_1 := constant_matrix * c_0 + constant_constants;
    all_constants := [c_0, c_1];
    k := Matrix(P, state_size, 1, [P.i : i in [0*state_size+1..1*state_size]]); // master key
    s_r := Matrix(P, state_size, 1, [P.i : i in [1*state_size+1..2*state_size]]); // state "right" of current section
    k_r := Matrix(P, state_size, 1, [P.i : i in [2*state_size+1..3*state_size]]); // key "right" of current section
    k_m := mat_pow(inv_mds_P * (k_r - c_1), s_box_power); // technically k_0, which is never an explicit variable
    polynomial_equations cat:= ElementToSequence(k + c_0 - k_m); // master key
    polynomial_equations cat:= ElementToSequence(plaintext + k + c_0 - mat_pow(inv_mds_P * (s_r - k_r), s_box_power)); // first step in first round
    for rnd in [1..num_rounds-1] do // first step and last step are treated differently
        c_0 := constant_matrix * c_1 + constant_constants; // even numbered...
        c_1 := constant_matrix * c_0 + constant_constants; // ... and odd numbered round constant
        all_constants cat:= [c_0, c_1];
        s_l := s_r;
        s_r := Matrix(P, state_size, 1, [P.i : i in [(2*rnd+1)*state_size+1..(2*rnd+2)*state_size]]);
        k_l := k_r;
        k_r := Matrix(P, state_size, 1, [P.i : i in [(2*rnd+2)*state_size+1..(2*rnd+3)*state_size]]);
        k_m := mds_P * mat_pow(k_l, s_box_power) + c_0; // middle key, never an explicit variable
        polynomial_equations cat:= ElementToSequence(k_m - mat_pow(inv_mds_P*(k_r - c_1), s_box_power)); // key schedule
        polynomial_equations cat:= ElementToSequence(mds_P * mat_pow(s_l, s_box_power) + k_m - mat_pow(inv_mds_P * (s_r - k_r), s_box_power)); // second step of one round & first step of next round
    end for;
    c_0 := constant_matrix * c_1 + constant_constants;
    all_constants cat:= [c_0];
    polynomial_equations cat:= ElementToSequence(mds_P * mat_pow(s_r, s_box_power) + mds_P * mat_pow(k_r, s_box_power) + c_0 - ciphertext); // second step in last round
    if sub_steps then
        return polynomial_equations, all_constants;
    end if;
    return polynomial_equations;
end function;

key := Matrix(field, state_size, 1, [1..state_size]);
pt := Matrix(field, state_size, 1, [10..state_size + 9]);
ct := rescue_encrypt(key, pt);
eqs := polynomial_system(pt, ct);
