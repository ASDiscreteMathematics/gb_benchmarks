security_level := 40;
field_size := 103;
state_size := 7;
s_box_power := 3;

SetSeed(42);

random_non_subfield_value := function (prime_field)
    while true do
        rand := Random(prime_field);
        if IsPrimitive(rand) then
            return rand;
        end if;
    end while;
end function;

rescue_initialize := function(security_level, field_size, state_size, s_box_power)
    assert IsPrime(field_size);
    assert state_size ge 1;
    assert Log(2, field_size) * state_size ge security_level;
    assert Gcd(s_box_power, field_size - 1) ne 1;
    field := FiniteField(field_size);
    _, invalpha, _ :=  Xgcd(s_box_power, field_size - 1);
    // determine number of rounds
    num_rounds := Max([10, 2 * Ceiling( (security_level + 2) / (4 * state_size))]);
    if s_box_power gt 3 then
        num_rounds := Max([10, 2 * Ceiling( (security_level + 3) / (5.5 * state_size))]);
    end if;
    // Generate MDS matrix
    p := PrimitiveElement(field);
    mds := Matrix([[p^(i*j) : i in [1..state_size*2]] : j in [1..state_size]]);
    mds := ColumnSubmatrix(EchelonForm(mds), state_size + 1, state_size);
    // Sample initial constant vector
    constant_initial := [];
    repeat
        constant_initial := Append(constant_initial, random_non_subfield_value(field));
    until #constant_initial eq state_size;
    constant_initial := Matrix([constant_initial]);
    // Sample constant matrix
    repeat
        constant_matrix := [];
        repeat
            constant_matrix := Append(constant_matrix, random_non_subfield_value(field));
        until #constant_matrix eq state_size^2;
        constant_matrix := Matrix(state_size, state_size, constant_matrix);
    until IsInvertible(constant_matrix);
    // Sample affine transformation of subsequent round constants
    constant_constants := [];
    repeat
        constant_constants := Append(constant_constants, random_non_subfield_value(field));
    until #constant_constants eq state_size;
    constant_constants := Matrix([constant_constants]);
    return field, invalpha, mds, constant_initial, constant_matrix, constant_constants, num_rounds;
end function;

field, invalpha, mds, constant_initial, constant_matrix, constant_constants, num_rounds := rescue_initialize(security_level, field_size, state_size, s_box_power);

rescue_encrypt := function (key, cleartext)
    ciphertext := cleartext;
    // TODO
    return ciphertext;
end function;

rescue_decrypt := function (key, ciphertext)
    cleartext := ciphertext;
    // TODO
    return cleartext;
end function;
