security_level := 40;
field_size := 103;
state_size := 7;
s_box_power := 3;

SetSeed(42);

vec_pow := func< vec, pow | Vector([i^pow : i in ElementToSequence(vec)])>;
mat_pow := func< mat, pow | Matrix(NumberOfRows(mat), NumberOfColumns(mat), [i^pow : i in ElementToSequence(mat)])>;

random_non_subfield_value := function (prime_field)
    assert IsPrime(#prime_field);
    while true do
        rand := Random(prime_field);
        if IsPrimitive(rand) then
            return rand;
        end if;
    end while;
end function;

rescue_initialize := function(security_level, field_size, state_size, s_box_power)
    assert IsPrime(field_size);
    assert state_size ge 1;
    assert Log(2, field_size) * state_size ge security_level;
    assert Gcd(s_box_power, field_size - 1) ne 1;
    field := FiniteField(field_size);
    _, inv_s_box_power, _ :=  Xgcd(s_box_power, field_size - 1);
    // determine number of rounds
    num_rounds := Max([10, 2 * Ceiling( (security_level + 2) / (4 * state_size))]);
    if s_box_power gt 3 then
        num_rounds := Max([10, 2 * Ceiling( (security_level + 3) / (5.5 * state_size))]);
    end if;
    // Generate MDS matrix
    p := PrimitiveElement(field);
    mds := Matrix([[p^(i*j) : i in [1..state_size*2]] : j in [1..state_size]]);
    mds := ColumnSubmatrix(EchelonForm(mds), state_size + 1, state_size);
    // Sample initial constant vector
    constant_initial := [];
    repeat
        Append(~constant_initial, random_non_subfield_value(field));
    until #constant_initial eq state_size;
    constant_initial := Matrix(field, state_size, 1, constant_initial);
    // Sample constant matrix
    repeat
        constant_matrix := [];
        repeat
            Append(~constant_matrix, random_non_subfield_value(field));
        until #constant_matrix eq state_size^2;
        constant_matrix := Matrix(field, state_size, state_size, constant_matrix);
    until IsInvertible(constant_matrix);
    // Sample affine transformation of subsequent round constants
    constant_constants := [];
    repeat
        Append(~constant_constants, random_non_subfield_value(field));
    until #constant_constants eq state_size;
    constant_constants := Matrix(field, state_size, 1, constant_constants);
    return field, inv_s_box_power, mds, constant_initial, constant_matrix, constant_constants, num_rounds;
end function;

// initialize
field, inv_s_box_power, mds, constant_initial, constant_matrix, constant_constants, num_rounds := rescue_initialize(security_level, field_size, state_size, s_box_power);

rescue_encrypt := function (key, plaintext)
    assert Parent(key) eq Parent(plaintext);
    assert Parent(key) eq Parent(constant_initial);
    assert Type(key) eq Type(plaintext);
    assert Type(key) eq Type(constant_initial);

    key_state := key;
    data_state := plaintext;

    key_injection := constant_initial;;
    key_state := key_state + key_injection;
    data_state := data_state + key_state;

    for r in [1..2*num_rounds] do
        step_power := s_box_power;
        if r mod 2 eq 0 then
            step_power := inv_s_box_power;
        end if;
        key_state := mat_pow(key_state, step_power);
        data_state := mat_pow(data_state, step_power);
        key_injection := constant_matrix * key_injection + constant_constants;
        key_state := mds * key_state + key_injection;
        data_state := mds * data_state + key_state;
    end for;

    return data_state;
end function;

rescue_decrypt := function (key, ciphertext)
    key_state := key;
    data_state := ciphertext;
    // TODO
    return data_state;
end function;

rescue_sponge := function (inputs, rate)
    assert NumberOfColumns(inputs) eq 1;
    assert BaseField(Parent(inputs)) eq field;
    assert rate le state_size;
    key := ZeroMatrix(field, state_size, 1);
    state := ZeroMatrix(field, state_size, 1);
    for i in [1..NumberOfRows(inputs) by rate] do
        for j in [1..Min(rate, NumberOfRows(inputs) - i)] do
            state[j, 1] := state[j, 1] + inputs[i+j, 1];
        end for;
        state := rescue_encrypt(key, state);
    end for;
    return RowSubmatrix(state, rate);
end function;

// absolutely minimal testing
test_rescue_encrypt := function ()
    key := Matrix(field, state_size, 1, [0..6]);
    pt := Matrix(field, state_size, 1, [40..46]);
    return rescue_encrypt(key, pt);
end function;

test_rescue_sponge := function ()
    msg := Matrix(field, 31, 1, [0..30]);
    return rescue_sponge(msg, 4);
end function;
