// Primary parameters
field_size := 101;
state_size := 3;
capacity := 1;
security_level := 80;

order := "grevlex";
is_low_round_number := true; // artifitially decrease security level for analytic purposes
num_lower_rounds := 3;

SetSeed(42);
SetNthreads(8);

import "common.magma" : vec_pow, mat_pow, d_reg, random_non_subfield_value, generate_mds_matrix;

function rescue_initialize (field_size, state_size, capacity, security_level)
    assert IsPrime(field_size);
    // assert Ceiling(Log(2, field_size)) ge 32;
    assert state_size gt 1;
    assert capacity lt state_size;
    assert 80 le security_level;
    assert security_level le 512;

    field := FiniteField(field_size);
    rate := state_size - capacity;

    s_box_power := 3;
    while Gcd(s_box_power, field_size - 1) ne 1 do
        s_box_power := s_box_power + 1;
    end while;
    _, s_box_power_inv, _ :=  Xgcd(s_box_power, field_size - 1);
    while s_box_power_inv lt 0 do
        s_box_power_inv := s_box_power_inv + field_size - 1;
    end while;

    d_con := func< n | Floor(0.5 * (s_box_power - 1) * state_size * (n - 1) + 2) >;
    v := func< n | state_size * (n - 1) + rate >;
    l_1 := 1;
    while l_1 le 25 and Binomial( d_con(l_1) + v(l_1), v(l_1) )^2 le 2^security_level do
        l_1 := l_1 + 1;
    end while;
    num_rounds := Ceiling(1.5 * Max(5, l_1));
    if is_low_round_number and num_rounds gt num_lower_rounds then
        num_rounds := num_lower_rounds;
    end if;

    mds := generate_mds_matrix(field, state_size);

    round_constants := [field | ]; // TODO: deviates from Rescue standard. Use SHAKE-256 instead.
    while #round_constants ne 2*state_size*num_rounds do
        round_constants cat:= [random_non_subfield_value(field)];
    end while;
    round_constants := Matrix(field, 2*num_rounds, state_size, round_constants);

    return field, num_rounds, rate, s_box_power, s_box_power_inv, mds, round_constants;
end function;

field, num_rounds, rate, s_box_power, s_box_power_inv, mds, round_constants := rescue_initialize(field_size, state_size, capacity, security_level);

function rescue_xlix (state : mds_is_id := false)
    assert #ElementToSequence(state) eq state_size;

    mds_to_use := mds;
    if mds_is_id then
        mds_to_use := IdentityMatrix(field, state_size);
    end if;

    state := Matrix(field, 1, state_size, ElementToSequence(state));
    for i in [1..2*num_rounds by 2] do
        state := mat_pow(state, s_box_power);
        state := state * mds_to_use;
        state := state + Matrix(round_constants[i]);
        state := mat_pow(state, s_box_power_inv);
        state := state * mds_to_use;
        state := state + Matrix(round_constants[i+1]);
    end for;
    return ElementToSequence(state);
end function;

function rescue_prime_hash (input_sequence)
    assert #ElementToSequence(input_sequence) mod rate eq 0;
    assert Universe(input_sequence) eq field;

    num_absorbs := Integers() ! (#ElementToSequence(input_sequence) / rate);
    num_squeezs := 1;
    state := ZeroMatrix(field, 1, state_size);
    input_sequence := Matrix(field, num_absorbs, rate, ElementToSequence(input_sequence));
    input_sequence := HorizontalJoin(input_sequence, ZeroMatrix(field, num_absorbs, capacity));
    for i in [1..num_absorbs] do
        state := state + input_sequence[i];
        state := rescue_xlix(state);
    end for;
    output_sequence := [field | ];
    for i in [1..num_squeezs] do
        output_sequence cat:= state[1..rate];
        state := rescue_xlix(state);
    end for;
    return output_sequence;
end function;

function rescue_prime_hash_wrapper (input_sequence)
    assert Universe(input_sequence) eq field;
    padded_input := ElementToSequence(input_sequence);
    if #padded_input mod rate ne 0 then
        padded_input cat:= [1];
    end if;
    while #padded_input mod rate ne 0 do
        padded_input cat:= [0];
    end while;
    return rescue_prime_hash(padded_input);
end function;

function polynomial_system_last_squeeze (hash_digest :
                                         unconstrained_input := false,
                                         mds_is_id := false,
                                         capacity_var := false,
                                         make_round_gbs := false,
                                         keep_gb := false)
    assert #hash_digest eq rate;

    num_vars := num_rounds*state_size + capacity;
    P<[x]> := PolynomialRing(field, num_vars, order);
    mds_P := Matrix(P, NumberOfRows(mds), NumberOfColumns(mds), [P ! e : e in ElementToSequence(mds)]);
    mds_P_inv := mds_P^(-1);
    if mds_is_id then
        mds_P := IdentityMatrix(P, state_size);
        mds_P_inv := mds_P;
    end if;
    polynomial_equations := [P.i : i in [rate+1..state_size]]; // capacity needs to be 0 at the start
    if unconstrained_input then
        polynomial_equations := [P | ]; // more relaxed system, all input can be whatever
    end if;

    round_next_vars := Matrix(P, 1, state_size, [P.i : i in [1..state_size]]);
    for r in [1..num_rounds] do
        round_vars := round_next_vars;
        if r lt num_rounds then
            round_next_vars := Matrix(P, 1, state_size, [P.i : i in [r*state_size+1..(r+1)*state_size]]);
        else // last round
            round_next_vars := hash_digest cat [P.i : i in [r*state_size+1..r*state_size+capacity]];
            round_next_vars := Matrix(P, 1, state_size, round_next_vars);
        end if;
        round_equations := round_next_vars - Matrix(round_constants[2*r]);
        round_equations := round_equations * mds_P_inv;
        round_equations := mat_pow(round_equations, s_box_power);
        round_equations := mat_pow(round_vars, s_box_power) * mds_P - round_equations;
        round_equations := Matrix(round_constants[2*r - 1]) + round_equations;
        if make_round_gbs then
            round_equations := GroebnerBasis(ElementToSequence(round_equations));
        end if;
        if r lt num_rounds or capacity_var then
            polynomial_equations cat:= ElementToSequence(round_equations);
        else
            polynomial_equations cat:= ElementToSequence(round_equations)[1..rate];
        end if;
        if keep_gb then
            polynomial_equations := GroebnerBasis(polynomial_equations);
        end if;
    end for;
    return [poly / LeadingCoefficient(poly) : poly in polynomial_equations];
end function;


for unconstrained_input in [false, true] do
    for mds_is_id in [false, true] do
        for capacity_var in [false, true] do
            for make_round_gbs in [false, true] do
                for keep_gb in [false, true] do
                    message := [1..rate] cat [0 : i in [rate+1..state_size]];
                    perm := rescue_xlix(message : mds_is_id := mds_is_id);
                    hash := perm[1..rate];
                    system := polynomial_system_last_squeeze(hash :
                                                             unconstrained_input := unconstrained_input,
                                                             mds_is_id := mds_is_id,
                                                             capacity_var := capacity_var,
                                                             make_round_gbs := make_round_gbs,
                                                             keep_gb := keep_gb);
                    printf "\n —————————————\n" ;
                    printf "unconstrained_input: %o\n", unconstrained_input ;
                    printf "mds_is_id:           %o\n", mds_is_id ;
                    printf "make_round_gbs:      %o\n", make_round_gbs ;
                    printf "keep_gb:             %o\n", keep_gb ;
                    printf "capacity_var:        %o\n\n", capacity_var ;
                    printf "input:  %o\noutput: %o\n", message, perm ;
                    print(system);
                    printf "is Gröbner: %o\n\n", IsGroebner(system) ;
                    // SetVerbose("Groebner", 1);
                    // SetVerbose("FGLM", 3);
                    system := GroebnerBasis(system);
                    // d_reg(system);
                    if IsGroebner(system) then
                        V := Variety(Ideal(system));
                        V_partial := [[v[i] : i in [1..state_size]] : v in V];
                        assert #V_partial eq #V;
                        if not message in V_partial then
                            print("[!!!] polynomial system probably incorrect.");
                        end if;
                    end if;
                end for;
            end for;
        end for;
    end for;
end for;
