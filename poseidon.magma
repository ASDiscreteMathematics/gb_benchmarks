// Primary parameters
field_size := 101;
state_size := 3;
s_box_power := 3;
security_level :=  0;

order := "grevlex";
is_low_round_number := true; // artifitially decrease security level for analytic purposes
num_lower_rounds := 4;

SetSeed(42);
SetNthreads(8);
check_gb_consistency := false;

import "common.magma" : vec_pow, mat_pow, sum_all, random_non_subfield_value, generate_mds_matrix, d_reg, macaulay_bound;

function poseidon_initialize (field_size, state_size, s_box_power, security_level)
    assert IsPrime(field_size);
    assert state_size gt 1;
    assert 2*state_size + 1 le field_size; // see Usenix Poseidon paper, Section 2.3, paragraph “The Linear Layer”
    assert Log(2, field_size) * state_size ge security_level;
    assert Gcd(s_box_power, field_size - 1) eq 1;

    field := FiniteField(field_size);

    // TODO see Usenix Poseidon paper, Section 2.3, paragraph “Avoiding Insecure Matrices”
    mds := generate_mds_matrix(field, state_size);

    // TODO see https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    assert IsEven(num_lower_rounds);
    num_full_rounds := Integers() ! (num_lower_rounds / 2);
    num_part_rounds := Integers() ! (num_lower_rounds / 2);
    num_rounds := num_full_rounds + num_part_rounds;
    assert IsEven(num_full_rounds);

    round_constants := [field | ];
    while #round_constants ne num_rounds*state_size do
        round_constants cat:= [random_non_subfield_value(field)];
    end while;
    round_constants := Matrix(field, num_rounds, state_size, round_constants);

    return field, mds, round_constants, num_full_rounds, num_part_rounds;
end function;

// initialize
field, mds, round_constants, num_full_rounds, num_part_rounds := poseidon_initialize(field_size, state_size, s_box_power, security_level);

function poseidon_permute (message : mds_is_id := false)
    assert #ElementToSequence(message) eq state_size;
    permutext := Matrix(field, 1, state_size, ElementToSequence(message));
    mds_to_use := mds;
    if mds_is_id then
        mds_to_use := IdentityMatrix(field, state_size);
    end if;
    for r in [1..(num_full_rounds + num_part_rounds)] do
        // add round constants
        permutext := permutext + Matrix(round_constants[r]);
        // sub words
        if (r le num_full_rounds / 2) or (num_full_rounds / 2 + num_part_rounds lt r) then // full round
            permutext := mat_pow(permutext, s_box_power);
        else // partial round
            permutext[1][state_size] := permutext[1][state_size]^s_box_power;
        end if;
        // mixlayer
        permutext := permutext * mds_to_use;
    end for;
    return ElementToSequence(permutext);
end function;

function build_mds_weights (matrix_size : invert_mds := false, capacity_upper_left := false)
    mds_to_use := mds;
    if invert_mds then
        mds_to_use := mds^(-1);
    end if;
    mds_size := #ElementToSequence(mds_to_use[1]);
    divid := Floor(matrix_size / mds_size);
    rem := matrix_size mod mds_size;
    trailing_matrix := ExtractBlock(mds_to_use, mds_size - rem + 1, mds_size - rem + 1, rem, rem);
    if capacity_upper_left then
        trailing_matrix := ExtractBlock(mds_to_use, 1, 1, rem, rem);
    end if;
    mds_weight_matrix := DiagonalJoin([mds_to_use : i in [1..divid]]);
    mds_weight_matrix := DiagonalJoin(mds_weight_matrix, trailing_matrix);
    mds_weights := ElementToSequence(mds_weight_matrix);
    mds_weights := [Integers() ! w : w in mds_weights];
    return mds_weights;
end function;

function polynomial_system_last_squeeze (hash_digest :
                                         unconstrained_input := false,
                                         mds_is_id := false,
                                         capacity_var := false,
                                         weight_order := false,
                                         invert_weight_mds := false,
                                         make_round_gbs := false,
                                         keep_gb := false)
    assert #hash_digest lt state_size;

    capacity := 0;
    if capacity_var then
        capacity := state_size - #hash_digest;
    end if;
    num_rounds := num_full_rounds + num_part_rounds;
    num_vars := num_rounds * state_size + capacity;
    P<[x]> := PolynomialRing(field, num_vars, order); // s_i = P.[i*m+1..(i+1)*m], capacity_end = P.[r*m+1..r*m+c]
    if weight_order then
        weights := build_mds_weights(num_vars : invert_mds := invert_weight_mds, capacity_upper_left := false);
        P<[x]> := PolynomialRing(field, num_vars, "weight", weights);
    end if;
    polynomial_equations := [P.i : i in [#hash_digest+1..state_size]]; // capacity needs to be 0 at the start
    if unconstrained_input then
        polynomial_equations := []; // more relaxed system, all input can be whatever
    end if;
    mds_to_use := Matrix(P, mds);
    if mds_is_id then
        mds_to_use := IdentityMatrix(P, state_size);
    end if;
    for r in [1..num_rounds] do
        round_vars := [P.i : i in [(r-1)*state_size+1..r*state_size]];
        round_vars := Matrix(1, state_size, round_vars);
        round_vars := round_vars + Matrix(round_constants[r]);
        if (r le num_full_rounds / 2) or (num_full_rounds / 2 + num_part_rounds lt r) then // full round
            round_vars := mat_pow(round_vars, s_box_power);
        else // partial round
            round_vars[1][state_size] := round_vars[1][state_size]^s_box_power;
        end if;
        round_vars := round_vars * mds_to_use;
        if r lt num_rounds then
            round_next_vars := [P.i : i in [r*state_size+1..(r+1)*state_size]];
        else // last round
            round_next_vars := hash_digest;
            round_next_vars cat:= [P.i : i in [r*state_size+1..r*state_size+capacity]]; // maybe variables for capacity
            round_vars := Matrix(1, #round_next_vars, ElementToSequence(round_vars)[1..#round_next_vars]);
        end if;
        round_next_vars := Matrix(1, #round_next_vars, round_next_vars);
        round_eqs := ElementToSequence(round_vars - round_next_vars);
        if make_round_gbs then
            round_eqs := GroebnerBasis(round_eqs);
        end if;
        polynomial_equations cat:= round_eqs;
        if keep_gb then
            polynomial_equations := GroebnerBasis(polynomial_equations);
        end if;
    end for;
    return [poly / LeadingCoefficient(poly) : poly in polynomial_equations];
end function;


for unconstrained_input in [true] do
    for mds_is_id in [false] do
        for capacity_var in [false] do
            for weight_order in [false] do
                for invert_weight_mds in [false] do
                    for make_round_gbs in [true] do
                        for keep_gb in [false] do
                            message := [1, 1, 0];
                            perm := poseidon_permute(message : mds_is_id := mds_is_id);
                            hash := perm[1..state_size - 1]; // implicitly setting rate to state_size-1, capacity to 1
                            system := polynomial_system_last_squeeze(hash :
                                                                     unconstrained_input := unconstrained_input,
                                                                     mds_is_id := mds_is_id,
                                                                     capacity_var := capacity_var,
                                                                     weight_order := weight_order,
                                                                     invert_weight_mds := invert_weight_mds,
                                                                     make_round_gbs := make_round_gbs,
                                                                     keep_gb := keep_gb);
                            printf "\n —————————————\n" ;
                            printf "monomial order:      %o\n", order ;
                            printf "unconstrained_input: %o\n", unconstrained_input ;
                            printf "mds_is_id:           %o\n", mds_is_id ;
                            printf "make_round_gbs:      %o\n", make_round_gbs ;
                            printf "keep_gb:             %o\n", keep_gb ;
                            printf "capacity_var:        %o\n", capacity_var ;
                            printf "weight_order:        %o\n", weight_order ;
                            printf "invert_mds:          %o\n", invert_weight_mds ;
                            printf "\n";
                            printf "input:  %o\noutput: %o\n", message, perm ;
                            print(system);
                            printf "is Gröbner:           %o\n", IsGroebner(system) ;
                            printf "macaulay bound:       %o\n", macaulay_bound(system);
                            SetVerbose("Groebner", 0);
                            SetVerbose("FGLM", 0);
                            system := GroebnerBasis(system);
                            printf "degree of regularity: %o\n", d_reg(system);
                            if check_gb_consistency then
                                print("executing consistency check …");
                                V := Variety(Ideal(system));
                                V_partial := [[v[i] : i in [1..state_size]] : v in V];
                                assert #V_partial eq #V;
                                if not message in V_partial then
                                    print("[!!!] polynomial system probably incorrect.");
                                end if;
                            end if;
                        end for;
                    end for;
                end for;
            end for;
        end for;
    end for;
end for;
