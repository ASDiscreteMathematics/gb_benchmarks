security_level := 0;
field_size := 101;
s_box_power := 3;
state_size := 3;
num_lower_number_of_rounds := 4;

SetSeed(42);
SetNthreads(8);
lower_number_of_rounds := true;
order := "grevlex";

import "common.magma" : vec_pow, mat_pow, random_non_subfield_value, generate_mds_matrix;

function poseidon_initialize (security_level, field_size, state_size, s_box_power)
    assert IsPrime(field_size);
    assert state_size ge 1;
    assert 2*state_size + 1 le field_size; // see Usenix Poseidon paper, Section 2.3, paragraph “The Linear Layer”
    assert Log(2, field_size) * state_size ge security_level;
    assert Gcd(s_box_power, field_size - 1) eq 1;
    // field
    field := FiniteField(field_size);
    // generate mds matrix
    // TODO see Usenix Poseidon paper, Section 2.3, paragraph “Avoiding Insecure Matrices”
    mds := generate_mds_matrix(field, state_size);
    // determine number of rounds
    // TODO see https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    assert IsEven(num_lower_number_of_rounds);
    num_full_rounds := IntegerRing() ! (num_lower_number_of_rounds / 2);
    num_part_rounds := IntegerRing() ! (num_lower_number_of_rounds / 2);
    num_rounds := num_full_rounds + num_part_rounds;
    assert IsEven(num_full_rounds);
    // sample round constants
    round_constants := [field | ]; // declare universe of sequence
    repeat
        Append(~round_constants, random_non_subfield_value(field));
    until #round_constants eq num_rounds*state_size;
    round_constants := Matrix(field, num_rounds, state_size, round_constants);
    return field, mds, round_constants, num_full_rounds, num_part_rounds;
end function;

// initialize
field, mds, round_constants, num_full_rounds, num_part_rounds := poseidon_initialize(security_level, field_size, state_size, s_box_power);

function poseidon_permute (message : mds_is_id := false)
    assert #ElementToSequence(message) eq state_size;
    permutext := Matrix(field, 1, state_size, ElementToSequence(message));
    mds_to_use := mds;
    if mds_is_id then
        mds_to_use := IdentityMatrix(field, state_size);
    end if;
    for r in [1..(num_full_rounds + num_part_rounds)] do
        // add round constants
        permutext := permutext + Matrix(round_constants[r]);
        // sub words
        if (r le num_full_rounds / 2) or (num_full_rounds / 2 + num_part_rounds lt r) then // full round
            permutext := mat_pow(permutext, s_box_power);
        else // partial round
            permutext[1][state_size] := permutext[1][state_size]^s_box_power;
        end if;
        // mixlayer
        permutext := permutext * mds_to_use;
    end for;
    return ElementToSequence(permutext);
end function;

function build_mds_weights (matrix_size : invert_mds := false, capacity_upper_left := false)
    mds_to_use := mds;
    if invert_mds then
        mds_to_use := mds^(-1);
    end if;
    mds_size := #ElementToSequence(mds_to_use[1]);
    divid := Floor(matrix_size / mds_size);
    rem := matrix_size mod mds_size;
    trailing_matrix := ExtractBlock(mds_to_use, mds_size - rem + 1, mds_size - rem + 1, rem, rem);
    if capacity_upper_left then
        trailing_matrix := ExtractBlock(mds_to_use, 1, 1, rem, rem);
    end if;
    mds_weight_matrix := DiagonalJoin([mds_to_use : i in [1..divid]]);
    mds_weight_matrix := DiagonalJoin(mds_weight_matrix, trailing_matrix);
    mds_weights := ElementToSequence(mds_weight_matrix);
    mds_weights := [IntegerRing() ! w : w in mds_weights];
    return mds_weights;
end function;

function polynomial_system_last_squeeze (hash_digest : unconstrained_input := false, mds_is_id := false, capacity_var := false, weight_order := false)
    assert #hash_digest lt state_size;
    capacity := 0;
    if capacity_var then
        capacity := state_size - #hash_digest;
    end if;
    num_rounds := num_full_rounds + num_part_rounds;
    num_vars := num_rounds * state_size + capacity;
    P<[x]> := PolynomialRing(field, num_vars, order); // s_i = P.[i*m+1..(i+1)*m], capacity_end = P.[r*m+1..r*m+c]
    if weight_order then
        weights := build_mds_weights(num_vars : invert_mds := true, capacity_upper_left := false);
        P<[x]> := PolynomialRing(field, num_vars, "weight", weights);
    end if;
    polynomial_equations := [P.i : i in [#hash_digest+1..state_size]]; // capacity needs to be 0 at the start
    if unconstrained_input then
        polynomial_equations := []; // more relaxed system, all input can be whatever
    end if;
    mds_to_use := Matrix(P, mds);
    if mds_is_id then
        mds_to_use := IdentityMatrix(P, state_size);
    end if;
    for r in [1..num_rounds] do
        round_vars := [P.i : i in [(r-1)*state_size+1..r*state_size]];
        round_vars := Matrix(1, state_size, round_vars);
        round_vars := round_vars + Matrix(round_constants[r]);
        if (r le num_full_rounds / 2) or (num_full_rounds / 2 + num_part_rounds lt r) then // full round
            round_vars := mat_pow(round_vars, s_box_power);
        else // partial round
            round_vars[1][state_size] := round_vars[1][state_size]^s_box_power;
        end if;
        round_vars := round_vars * mds_to_use;
        if r lt num_rounds then
            round_next_vars := [P.i : i in [r*state_size+1..(r+1)*state_size]];
        else // last round
            round_next_vars := hash_digest;
            round_next_vars cat:= [P.i : i in [r*state_size+1..r*state_size+capacity]]; // maybe add variables for capacity at end
            round_vars := Matrix(1, #round_next_vars, ElementToSequence(round_vars)[1..#round_next_vars]);
        end if;
        round_next_vars := Matrix(1, #round_next_vars, round_next_vars);
        polynomial_equations cat:= ElementToSequence(round_vars - round_next_vars);
    end for;
    return [poly / LeadingCoefficient(poly) : poly in polynomial_equations];
end function;


for unconstrained_input in [false, true] do
    for mds_is_id in [false, true] do
        for capacity_var in [false, true] do
            for weight_order in [false, true] do
                message := [1, 1, 0];
                perm := poseidon_permute(message : mds_is_id := mds_is_id);
                hash := perm[1..state_size - 1]; // implicitly setting rate to state_size-1, capacity to 1
                system := polynomial_system_last_squeeze(hash :
                                                            unconstrained_input := unconstrained_input,
                                                            mds_is_id := mds_is_id,
                                                            capacity_var := capacity_var,
                                                            weight_order := weight_order);
                printf "\n —————————————\n" ;
                printf "unconstrained_input: %o\n", unconstrained_input ;
                printf "mds_is_id:           %o\n", mds_is_id ;
                printf "capacity_var:        %o\n\n", capacity_var ;
                printf "input:  %o\noutput: %o\n\n", message, perm ;
                // print(system);
                printf "is Gröbner: %o\n\n", IsGroebner(system) ;
                if IsGroebner(system) then
                    V := Variety(Ideal(system));
                    V_partial := [[v[i] : i in [1..state_size]] : v in V];
                    assert #V_partial eq #V;
                    if not message in V_partial then
                        print("System appears to be incorrect.");
                    end if;
                end if;
            end for;
        end for;
    end for;
end for;
